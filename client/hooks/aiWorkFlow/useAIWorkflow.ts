import { useState, useCallback, useEffect } from 'react';
import { useRouter } from 'expo-router';
import { useClients } from '@/hooks/data/useClients';
import { Attachment, ProposedTask } from '@/types';
import AIService from '@/services/aiService';
import { useProcessing } from '@/hooks/infrastructure/useProcessing';

interface AIWorkflowParams {
  attachments?: Attachment[];
  sourceType?: 'ocr' | 'asr';
  stackIndex?: string;
  stackTotal?: string;
}

interface AIWorkflowState {
  // Status
  isActive: boolean;

  // Current task context
  currentTask: ProposedTask | null;
  currentIndex: number;
  totalTasks: number;

  // Actions
  startProcessing: () => void;
  continueFlow: (onComplete?: () => void) => Promise<string>;
}

// Internal workflow state (shared across hook instances)
type WorkflowState = {
  tasks: ProposedTask[];
  sourceType: 'ocr' | 'asr' | null;
};

let workflowState: WorkflowState = {
  tasks: [],
  sourceType: null,
};

let stateSubscribers: Set<() => void> = new Set();

const updateWorkflow = {
  setTasks(tasks: ProposedTask[], sourceType: 'ocr' | 'asr') {
    workflowState.tasks = tasks;
    workflowState.sourceType = sourceType;
    stateSubscribers.forEach(notify => notify());
  },
  reset() {
    workflowState.tasks = [];
    workflowState.sourceType = null;
    stateSubscribers.forEach(notify => notify());
  }
};

/**
 * AI Workflow Hook
 *
 * Manages AI-powered task processing and navigation flow.
 * Handles file processing, task generation, and multi-task workflows.
 */
export function useAIWorkflow({
  attachments = [],
  sourceType = 'ocr',
  stackIndex,
  stackTotal
}: AIWorkflowParams = {}): AIWorkflowState {
  const router = useRouter();
  const { clients } = useClients();
  const [triggerProcessing, setTriggerProcessing] = useState(false);
  const { startAIProcessing, stopProcessing } = useProcessing();
  const [, forceRerender] = useState({});

  // Subscribe to workflow state changes
  useEffect(() => {
    const notify = () => forceRerender({});
    stateSubscribers.add(notify);
    return () => {
      stateSubscribers.delete(notify);
    };
  }, []);

  // Process attachments through AI when triggered
  const processFiles = useCallback(async () => {
    try {
      startAIProcessing();

      const tempFiles = attachments.filter(att => att.isTemporary);
      const fileUrls = tempFiles
        .filter(att => (att as any).publicUrl)
        .map(att => (att as any).publicUrl!);

      if (fileUrls.length === 0) {
        console.warn('No valid file URLs found');
        stopProcessing();
        return;
      }

      const clientContext = clients.map(client => ({
        id: client.id,
        client_name: client.client_name
      }));

      const aiService = AIService.getInstance();
      const response = await aiService.proposeTasks({
        source_type: sourceType,
        source_file_urls: fileUrls,
        client_list: clientContext
      });

      if (response.success && response.proposed_tasks?.length > 0) {
        updateWorkflow.setTasks(response.proposed_tasks, sourceType);
        console.log(`AI generated ${response.proposed_tasks.length} tasks`);
      } else {
        console.warn('No tasks generated by AI');
        stopProcessing();
      }
    } catch (error) {
      console.error('AI processing failed:', error);
      stopProcessing();
    }finally {
      stopProcessing();
    }
  }, [attachments, clients, sourceType, startAIProcessing, stopProcessing]);

  // Auto-process when triggered and files are available
  useEffect(() => {
    if (triggerProcessing && attachments.some(att => att.isTemporary)) {
      setTriggerProcessing(false);
      processFiles();
    }
  }, [triggerProcessing, attachments, processFiles]);

  // Navigate through the task flow
  const continueFlow = useCallback(async (onComplete?: () => void): Promise<string> => {
    const currentIndex = stackIndex ? parseInt(stackIndex, 10) : 1;
    const totalCount = workflowState.tasks.length || (stackTotal ? parseInt(stackTotal, 10) : 1);
    const nextIndex = currentIndex + 1;

    if (nextIndex <= totalCount) {
      router.replace({
        pathname: '/task',
        params: {
          mode: 'ai-flow',
          stackIndex: nextIndex.toString(),
          stackTotal: totalCount.toString()
        }
      });
      return `Task ${currentIndex} processed! Showing task ${nextIndex} of ${totalCount}`;
    } else {
      updateWorkflow.reset();
      await onComplete?.();
      router.back();
      return "All tasks completed successfully!";
    }
  }, [stackIndex, stackTotal, router]);

  // Compute current workflow context
  const hasActiveTasks = workflowState.tasks.length > 0;
  const isFlowActive = hasActiveTasks || !!(stackIndex && stackTotal);
  const currentIndex = stackIndex ? parseInt(stackIndex, 10) : 1;
  const totalTasks = hasActiveTasks ? workflowState.tasks.length : (stackTotal ? parseInt(stackTotal, 10) : 1);

  // Get current task for display
  const currentTask = (() => {
    const index = currentIndex - 1; // Convert to 0-based
    return (index >= 0 && index < workflowState.tasks.length)
      ? workflowState.tasks[index]
      : null;
  })();

  return {
    // Status
    isActive: isFlowActive,

    // Current context
    currentTask,
    currentIndex,
    totalTasks,

    // Actions
    startProcessing: () => setTriggerProcessing(true),
    continueFlow,
  };
}